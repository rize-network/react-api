{{>header}}

{{#if imports}}
{{#each imports}}
import type { {{{this}}} } from '../models/{{{this}}}';
{{/each}}
{{/if}}
import { useCallback, useRef } from 'react';
import type { CancelablePromise } from '../core/CancelablePromise';
import { request as __request, upload, download } from '../core/request';
import { useRequest, UseRequestOption, UseRequestProperties } from '@app-studio/react-request';

{{#if @root.useVersion}}
import { OpenAPI } from '../core/OpenAPI';
{{/if}}

    {{#each operations}}
    /**
    {{#if deprecated}}
     * @deprecated
    {{/if}}
    {{#if summary}}
     * {{{summary}}}
    {{/if}}
    {{#if description}}
     * {{{description}}}
    {{/if}}
    {{#unless @root.useOptions}}
    {{#if parameters}}
    {{#each parameters}}
     * @param {{{name}}} {{{description}}}
    {{/each}}
    {{/if}}
    {{/unless}}
    {{#each results}}
     * @returns {{{type}}} {{{description}}}
    {{/each}}
     * @throws ApiError
     */
  export const {{{name}}} = ({{>parameters}}{{#contains name 'Upload'}} onProgress {{/contains}}{{#contains name 'Download'}} onProgress {{/contains}}): CancelablePromise<{{>result}}> => {


        return {{#contains name 'Upload'}}upload{{else}}{{#contains name 'Download'}}download{{else}}__request{{/contains}}{{/contains}}({
            {{#contains name 'Upload'}}onProgress,{{/contains}}
            {{#contains name 'Download'}}onProgress,{{/contains}}
            method: '{{{method}}}',
            path: `{{{path}}}`,
            {{#if parametersCookie}}
            cookies: {
                {{#each parametersCookie}}
                '{{{prop}}}': {{{name}}},
                {{/each}}
            },
            {{/if}}
            {{#if parametersHeader}}
            headers: {
                {{#each parametersHeader}}
                '{{{prop}}}': {{{name}}},
                {{/each}}
            },
            {{/if}}
            {{#if parametersQuery}}
            query: {
                {{#each parametersQuery}}
                '{{{prop}}}': {{{name}}},
                {{/each}}
            },
            {{/if}}
            {{#if parametersForm}}
            formData: {
                {{#each parametersForm}}
                '{{{prop}}}': {{{name}}},
                {{/each}}
            },
            {{/if}}
            {{#if parametersBody}}
            {{#equals parametersBody.in 'formData'}}
            formData: {{{parametersBody.name}}},
            {{/equals}}
            {{#equals parametersBody.in 'body'}}
            body: {{{parametersBody.name}}},
            {{/equals}}
            {{#if parametersBody.mediaType}}
            mediaType: '{{{parametersBody.mediaType}}}',
            {{/if}}
            {{/if}}
            {{#if responseHeader}}
            responseHeader: '{{{responseHeader}}}',
            {{/if}}
            {{#if errors}}
            errors: {
                {{#each errors}}
                {{{code}}}: `{{{description}}}`,
                {{/each}}
            },
            {{/if}}
        });
    }

    {{/each}}


{{#each operations}}

{{#contains name 'Upload'}}
export const {{{hookName}}}{{{@root.postfix}}} = ({method =  '{{{method}}}', onProgress, ...options}:UseRequestOption & { onProgress?: (progress: number) => void } = {}) : {
    run: ({{>params}}) => void;
    data: {{>result}};
} & UseRequestProperties => {
    // Use ref to store onProgress to avoid recreating wrapper on every render
    const onProgressRef = useRef(onProgress);
    onProgressRef.current = onProgress;

    // Memoized wrapper to pass onProgress callback to upload function
    const uploadWithProgress = useCallback(({{>params}}) => {
        return {{{name}}}({{>paramNames}}, onProgressRef.current);
    }, []);

    return useRequest(uploadWithProgress, { method, ...options });
}
{{else}}
{{#contains name 'Download'}}
export const {{{hookName}}}{{{@root.postfix}}} = ({method =  '{{{method}}}', onProgress, ...options}:UseRequestOption & { onProgress?: (progress: number) => void } = {}) : {
    run: ({{>params}}) => void;
    data: {{>result}};
} & UseRequestProperties => {
    // Use ref to store onProgress to avoid recreating wrapper on every render
    const onProgressRef = useRef(onProgress);
    onProgressRef.current = onProgress;

    // Memoized wrapper to pass onProgress callback to download function
    const downloadWithProgress = useCallback(({{>params}}) => {
        return {{{name}}}({{>paramNames}}, onProgressRef.current);
    }, []);

    return useRequest(downloadWithProgress, { method, ...options });
}
{{else}}
export const {{{hookName}}}{{{@root.postfix}}} = ({method =  '{{{method}}}', ...options}:UseRequestOption = {}) : {
    run: ({{>params}}) => void;
    data: {{>result}};
} & UseRequestProperties => {
    return useRequest({{{name}}},{ method, ...options});
}
{{/contains}}
{{/contains}}

{{/each}}